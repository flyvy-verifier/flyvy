# Copyright 2022-2023 VMware, Inc.
# SPDX-License-Identifier: BSD-2-Clause

## This file was generated from mypyvy.
##
## ./src/mypyvy.py typecheck --print-program=fly examples/fol/vertical_paxos_epr.pyv
##
## Manually added "always" to axiom.
## Manually enforced immutability using additional axioms.

# sorts:
sort round
sort value
sort config
sort quorum
sort node

# constants:
immutable none: value
mutable master_complete: round

# functions:
mutable quorum_of_round(round): quorum

# relations:
immutable le(round, round): bool
immutable member(node, quorum): bool
immutable quorumin(quorum, config): bool
immutable complete_of(config, round): bool
mutable one_a(round, round): bool
mutable one_b(node, round, round): bool
mutable left_round(node, round): bool
mutable proposal(round, value): bool
mutable vote(node, round, value): bool
mutable decision(round, value): bool
mutable configure_round_msg(round, config): bool
mutable complete_msg(round): bool

# immutability (added by hand)
assume always (none = none')
assume always (forall R1:round, R2:round. le(R1, R2) = (le(R1, R2))')
assume always (forall N:node, Q:quorum. member(N, Q) = (member(N, Q))')
assume always (forall Q:quorum, C:config. quorumin(Q, C) = (quorumin(Q, C))')
assume always (forall C:config, R:round. complete_of(C, R) = (complete_of(C, R))')

# axioms:
assume always (forall X:round. le(X, X)) & (forall X:round, Y:round, Z:round. le(X, Y) & le(Y, Z) -> le(X, Z)) & (forall X:round, Y:round. le(X, Y) & le(Y, X) -> X = Y) & (forall X:round, Y:round. le(X, Y) | le(Y, X)) & (forall C:config, Q1:quorum, Q2:quorum. quorumin(Q1, C) & quorumin(Q2, C) -> (exists N:node. member(N, Q1) & member(N, Q2))) & (forall C:config, R1:round, R2:round. complete_of(C, R1) & complete_of(C, R2) -> R1 = R2)

# init:
assume (forall R1:round, R2:round. !one_a(R1, R2)) & (forall N:node, R1:round, R2:round. !one_b(N, R1, R2)) & (forall N:node, R:round. !left_round(N, R)) & (forall R:round, V:value. !proposal(R, V)) & (forall N:node, R:round, V:value. !vote(N, R, V)) & (forall R:round, V:value. !decision(R, V)) & (forall R:round, C:config. !configure_round_msg(R, C)) & (forall R:round. !complete_msg(R)) & (forall R:round. le(master_complete, R))

# transitions:
assume always (exists r:round, c:config. (forall C:config. !configure_round_msg(r, C)) & le(master_complete, r) & complete_of(c, master_complete) & (forall R:round, C:config. (configure_round_msg(R, C))' <-> configure_round_msg(R, C) | R = r & C = c) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (master_complete)' = master_complete & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0))) | (exists r:round. complete_msg(r) & !le(r, master_complete) & (master_complete)' = r & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0))) | (exists r:round, c:config, cr:round. configure_round_msg(r, c) & complete_of(c, cr) & (forall R1:round, R2:round. (one_a(R1, R2))' <-> one_a(R1, R2) | R1 = r & le(cr, R2) & !le(r, R2)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (master_complete)' = master_complete & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0))) | (exists n:node, r:round, rp:round. one_a(r, rp) & !left_round(n, r) & (forall N:node, R1:round, R2:round. (one_b(N, R1, R2))' <-> one_b(N, R1, R2) | N = n & R1 = r & R2 = rp) & (forall N:node, R:round. (left_round(N, R))' <-> left_round(N, R) | N = n & !le(r, R)) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (master_complete)' = master_complete & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0))) | (exists r:round, c:config, cr:round, v:value. (forall R:round. (quorum_of_round(R))' = (quorum_of_round(R))') & configure_round_msg(r, c) & complete_of(c, cr) & (forall V:value. !proposal(r, V)) & (forall R:round. le(cr, R) & !le(r, R) -> (exists C:config. configure_round_msg(R, C))) & (forall R:round, C:config. le(cr, R) & !le(r, R) & configure_round_msg(R, C) -> quorumin(quorum_of_round(R), C)) & (forall R:round, N:node. le(cr, R) & !le(r, R) & member(N, quorum_of_round(R)) -> one_b(N, r, R)) & (forall N:node, MAXR:round, V:value. !(le(cr, MAXR) & !le(r, MAXR) & member(N, quorum_of_round(MAXR)) & vote(N, MAXR, V))) & (forall R:round. (complete_msg(R))' <-> complete_msg(R) | R = r) & v != none & (forall R:round, V:value. (proposal(R, V))' <-> proposal(R, V) | R = r & V = v) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (master_complete)' = master_complete) | (exists r:round, c:config, cr:round, maxr:round, v:value. (forall R:round. (quorum_of_round(R))' = (quorum_of_round(R))') & configure_round_msg(r, c) & complete_of(c, cr) & (forall V:value. !proposal(r, V)) & (forall R:round. le(cr, R) & !le(r, R) -> (exists C:config. configure_round_msg(R, C))) & (forall R:round, C:config. le(cr, R) & !le(r, R) & configure_round_msg(R, C) -> quorumin(quorum_of_round(R), C)) & (forall R:round, N:node. le(cr, R) & !le(r, R) & member(N, quorum_of_round(R)) -> one_b(N, r, R)) & v != none & (exists N:node. le(cr, maxr) & !le(r, maxr) & member(N, quorum_of_round(maxr)) & vote(N, maxr, v)) & (forall N:node, MAXR:round, V:value. le(cr, MAXR) & !le(r, MAXR) & member(N, quorum_of_round(MAXR)) & vote(N, MAXR, V) -> le(MAXR, maxr)) & (forall R:round, V:value. (proposal(R, V))' <-> proposal(R, V) | R = r & V = v) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (master_complete)' = master_complete) | (exists n:node, v:value, r:round. v != none & !left_round(n, r) & proposal(r, v) & (forall N:node, R:round, V:value. (vote(N, R, V))' <-> vote(N, R, V) | N = n & R = r & V = v) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:round, x1:value. (decision(x0, x1))' = decision(x0, x1)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (forall x0:round. (complete_msg(x0))' = complete_msg(x0)) & (master_complete)' = master_complete & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0))) | (exists r:round, c:config, v:value, q:quorum. v != none & configure_round_msg(r, c) & quorumin(q, c) & (forall N:node. member(N, q) -> vote(N, r, v)) & (forall R:round, V:value. (decision(R, V))' <-> decision(R, V) | R = r & V = v) & (forall R:round. (complete_msg(R))' <-> complete_msg(R) | R = r) & (forall x0:round, x1:round. (one_a(x0, x1))' = one_a(x0, x1)) & (forall x0:node, x1:round, x2:round. (one_b(x0, x1, x2))' = one_b(x0, x1, x2)) & (forall x0:node, x1:round. (left_round(x0, x1))' = left_round(x0, x1)) & (forall x0:round, x1:value. (proposal(x0, x1))' = proposal(x0, x1)) & (forall x0:node, x1:round, x2:value. (vote(x0, x1, x2))' = vote(x0, x1, x2)) & (forall x0:round, x1:config. (configure_round_msg(x0, x1))' = configure_round_msg(x0, x1)) & (master_complete)' = master_complete & (forall x0:round. (quorum_of_round(x0))' = quorum_of_round(x0)))

# safety:
assert always (forall R1:round, V1:value, R2:round, V2:value. decision(R1, V1) & decision(R2, V2) -> V1 = V2)
proof {
    invariant forall R1:round, V1:value, R2:round, V2:value. decision(R1, V1) & decision(R2, V2) -> V1 = V2
    invariant forall R:round, V1:value, V2:value. proposal(R, V1) & proposal(R, V2) -> V1 = V2
    invariant forall N:node, R:round, V:value. vote(N, R, V) -> proposal(R, V)
    invariant forall R1:round, R2:round, V:value. proposal(R2, V) & le(R1, R2) -> (exists C:config. configure_round_msg(R1, C))
    invariant forall R2:round, R3:round, C:config, R1:round. (R2 = master_complete | configure_round_msg(R3, C) & complete_of(C, R2)) & !le(R2, R1) -> complete_msg(R2)
    invariant forall R1:round, R2:round. complete_msg(R2) & le(R1, R2) -> (exists C:config. configure_round_msg(R1, C))
    invariant forall R:round, V:value. decision(R, V) -> (exists C:config, Q:quorum. configure_round_msg(R, C) & quorumin(Q, C) & (forall N:node. member(N, Q) -> vote(N, R, V)))
    invariant forall R1:round, R2:round, V1:value, V2:value, Q:quorum, C:config. !le(R2, R1) & proposal(R2, V2) & V1 != V2 & configure_round_msg(R1, C) & quorumin(Q, C) -> (exists N:node. member(N, Q) & left_round(N, R1) & !vote(N, R1, V1))
    invariant forall R:round, C:config, MINREL:round. configure_round_msg(R, C) & complete_of(C, MINREL) -> le(MINREL, R) & le(MINREL, master_complete)
    invariant forall RR:round, R:round, C:config, Q:quorum, V:value. complete_msg(RR) & !le(RR, R) & configure_round_msg(R, C) & quorumin(Q, C) & !decision(RR, V) -> (exists N:node. member(N, Q) & left_round(N, R) & !vote(N, R, V))
    invariant forall N:node, R1:round, R2:round, R3:round. one_b(N, R1, R2) & !le(R1, R3) -> left_round(N, R3)
}
